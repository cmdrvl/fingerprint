use crate::compile::codegen::generate_rust;
use crate::dsl::parser::FingerprintDefinition;
use std::fs;
use std::path::Path;

/// Generate a complete Rust crate (Cargo.toml, src/lib.rs, fixtures/) from a DSL definition.
pub fn generate_crate(def: &FingerprintDefinition, out_dir: &Path) -> Result<(), String> {
    // Create output directory if it doesn't exist
    fs::create_dir_all(out_dir).map_err(|e| {
        format!(
            "Failed to create output directory '{}': {}",
            out_dir.display(),
            e
        )
    })?;

    // Generate Cargo.toml
    let cargo_toml = generate_cargo_toml(def);
    let cargo_toml_path = out_dir.join("Cargo.toml");
    fs::write(&cargo_toml_path, cargo_toml)
        .map_err(|e| format!("Failed to write Cargo.toml: {}", e))?;

    // Generate src/lib.rs
    let src_dir = out_dir.join("src");
    fs::create_dir_all(&src_dir).map_err(|e| format!("Failed to create src directory: {}", e))?;

    let rust_source = generate_rust(def)?;
    let lib_rs_path = src_dir.join("lib.rs");
    fs::write(&lib_rs_path, rust_source)
        .map_err(|e| format!("Failed to write src/lib.rs: {}", e))?;

    // Create fixtures/ directory stub
    let fixtures_dir = out_dir.join("fixtures");
    fs::create_dir_all(&fixtures_dir)
        .map_err(|e| format!("Failed to create fixtures directory: {}", e))?;

    // Create a placeholder README in fixtures/
    let fixtures_readme = generate_fixtures_readme(def);
    let fixtures_readme_path = fixtures_dir.join("README.md");
    fs::write(&fixtures_readme_path, fixtures_readme)
        .map_err(|e| format!("Failed to write fixtures/README.md: {}", e))?;

    Ok(())
}

/// Generate Cargo.toml content for the fingerprint crate.
fn generate_cargo_toml(def: &FingerprintDefinition) -> String {
    let crate_name = sanitize_crate_name(&def.fingerprint_id);
    let description = format!("Generated fingerprint crate for {}", def.fingerprint_id);

    format!(
        r#"[package]
name = "{crate_name}"
version = "0.1.0"
edition = "2021"
description = "{description}"

# Generated by fingerprint v{compiler_version}
# Source: DSL definition for {fingerprint_id}

[dependencies]
fingerprint = {{ path = "../.." }}
serde_json = "1.0"

[lib]
name = "{lib_name}"
crate-type = ["cdylib", "rlib"]
"#,
        crate_name = crate_name,
        description = description,
        compiler_version = env!("CARGO_PKG_VERSION"),
        fingerprint_id = def.fingerprint_id,
        lib_name = crate_name.replace("-", "_"),
    )
}

/// Generate fixtures/README.md content.
fn generate_fixtures_readme(def: &FingerprintDefinition) -> String {
    format!(
        r#"# Fixtures for {}

This directory is intended for test fixtures that demonstrate the fingerprint matching behavior.

## Usage

Place sample files that match this fingerprint in this directory:
- `positive/` - Files that should match the fingerprint
- `negative/` - Files that should NOT match the fingerprint

## Format

This fingerprint is designed for `{}` format files.

## Generated

This crate was generated from a DSL definition by fingerprint v{}.
"#,
        def.fingerprint_id,
        def.format,
        env!("CARGO_PKG_VERSION")
    )
}

/// Sanitize a fingerprint ID to be a valid Rust crate name.
fn sanitize_crate_name(fingerprint_id: &str) -> String {
    // Replace dots with hyphens and ensure it starts with a letter
    let sanitized = fingerprint_id
        .replace('.', "-")
        .chars()
        .map(|c| {
            if c.is_alphanumeric() || c == '-' || c == '_' {
                c
            } else {
                '-'
            }
        })
        .collect::<String>();

    // Ensure it starts with a letter (prefix with "fp-" if it doesn't)
    if sanitized
        .chars()
        .next()
        .is_none_or(|c| !c.is_ascii_alphabetic())
    {
        format!("fp-{}", sanitized)
    } else {
        sanitized
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dsl::parser::FingerprintDefinition;

    #[test]
    fn sanitize_crate_name_handles_dots() {
        assert_eq!(sanitize_crate_name("argus-model.v1"), "argus-model-v1");
        assert_eq!(sanitize_crate_name("csv.v0"), "csv-v0");
    }

    #[test]
    fn sanitize_crate_name_handles_invalid_characters() {
        assert_eq!(sanitize_crate_name("test@model#v1"), "test-model-v1");
        assert_eq!(sanitize_crate_name("test/model\\v1"), "test-model-v1");
    }

    #[test]
    fn sanitize_crate_name_handles_numeric_start() {
        assert_eq!(sanitize_crate_name("123-model"), "fp-123-model");
        assert_eq!(sanitize_crate_name("2pdf.v1"), "fp-2pdf-v1");
    }

    #[test]
    fn generate_cargo_toml_produces_valid_toml() {
        let def = FingerprintDefinition {
            fingerprint_id: "test-model.v1".to_string(),
            format: "xlsx".to_string(),
            valid_from: None,
            valid_until: None,
            parent: None,
            assertions: vec![],
            extract: vec![],
            content_hash: None,
        };

        let toml_content = generate_cargo_toml(&def);

        assert!(toml_content.contains("name = \"test-model-v1\""));
        assert!(toml_content.contains("Generated by fingerprint"));
        assert!(toml_content.contains("test-model.v1"));
    }

    #[test]
    fn generate_crate_creates_full_structure() {
        use tempfile::TempDir;

        let def = FingerprintDefinition {
            fingerprint_id: "test.v0".to_string(),
            format: "csv".to_string(),
            valid_from: None,
            valid_until: None,
            parent: None,
            assertions: vec![],
            extract: vec![],
            content_hash: None,
        };

        let temp_dir = TempDir::new().expect("create temp dir");
        generate_crate(&def, temp_dir.path()).expect("generate crate");

        // Verify Cargo.toml exists and contains expected content
        let cargo_toml_path = temp_dir.path().join("Cargo.toml");
        assert!(cargo_toml_path.exists());
        let cargo_content = std::fs::read_to_string(&cargo_toml_path).expect("read Cargo.toml");
        assert!(cargo_content.contains("name = \"test-v0\""));

        // Verify src/lib.rs exists and contains generated code
        let lib_rs_path = temp_dir.path().join("src/lib.rs");
        assert!(lib_rs_path.exists());
        let lib_content = std::fs::read_to_string(&lib_rs_path).expect("read lib.rs");
        assert!(lib_content.contains("impl Fingerprint for GeneratedFingerprint"));
        assert!(lib_content.contains("test.v0"));

        // Verify fixtures directory exists
        let fixtures_dir = temp_dir.path().join("fixtures");
        assert!(fixtures_dir.exists());
        let fixtures_readme = fixtures_dir.join("README.md");
        assert!(fixtures_readme.exists());
    }
}
