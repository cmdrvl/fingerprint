use crate::dsl::assertions::NamedAssertion;
use crate::dsl::parser::{ContentHashConfig, ExtractSection, FingerprintDefinition};
use blake3::Hasher;
use serde_yaml;

/// Generate Rust source implementing the Fingerprint trait from a parsed DSL definition.
pub fn generate_rust(def: &FingerprintDefinition) -> Result<String, String> {
    let source_hash = compute_definition_hash(def)?;
    let compiler_version = env!("CARGO_PKG_VERSION");
    let valid_from = option_string_literal(def.valid_from.as_deref());
    let valid_until = option_string_literal(def.valid_until.as_deref());
    let parent = option_string_literal(def.parent.as_deref());

    let assertions_code = generate_assertions_code(&def.assertions)?;
    let extracted_code = generate_extracted_code(&def.extract);
    let content_hash_code = generate_content_hash_code(&def.content_hash);

    let rust_code = format!(
        r#"//! Generated fingerprint implementation from DSL definition.
//!
//! This file was auto-generated by fingerprint v{compiler_version}.
//! DO NOT EDIT MANUALLY.

use fingerprint::{{Document, Fingerprint, FingerprintResult}};
use fingerprint::dsl::assertions::{{diagnose_mode, evaluate_named_assertions_with_diagnose, ColumnPattern, NamedAssertion}};
use fingerprint::dsl::assertions::Assertion::*;

pub struct GeneratedFingerprint {{}}

impl Fingerprint for GeneratedFingerprint {{
    fn id(&self) -> &str {{
        "{fingerprint_id}"
    }}

    fn format(&self) -> &str {{
        "{format}"
    }}

    fn parent(&self) -> Option<&str> {{
        {parent}
    }}

    fn fingerprint(&self, doc: &Document) -> FingerprintResult {{
        let diagnose = diagnose_mode();

{assertions_code}

        // Extract content if all assertions passed
        let extracted = if all_passed {{
{extracted_code}
        }} else {{
            None
        }};

        // Compute content hash if enabled and assertions passed
        let content_hash = if all_passed {{
{content_hash_code}
        }} else {{
            None
        }};

        FingerprintResult {{
            matched: all_passed,
            reason: first_failure_reason,
            assertions: passed_assertions,
            extracted,
            content_hash,
        }}
    }}
}}

/// Metadata about the generated fingerprint.
pub const FINGERPRINT_METADATA: FingerprintMetadata = FingerprintMetadata {{
    fingerprint_id: "{fingerprint_id}",
    format: "{format}",
    parent: {parent},
    valid_from: {valid_from},
    valid_until: {valid_until},
    compiler_version: "{compiler_version}",
    source_hash: "{source_hash}",
    source: "dsl",
}};

#[derive(Debug, Clone)]
pub struct FingerprintMetadata {{
    pub fingerprint_id: &'static str,
    pub format: &'static str,
    pub parent: Option<&'static str>,
    pub valid_from: Option<&'static str>,
    pub valid_until: Option<&'static str>,
    pub compiler_version: &'static str,
    pub source_hash: &'static str,
    pub source: &'static str,
}}
"#,
        compiler_version = compiler_version,
        fingerprint_id = def.fingerprint_id,
        format = def.format,
        parent = parent,
        valid_from = valid_from,
        valid_until = valid_until,
        source_hash = source_hash,
        assertions_code = assertions_code,
        extracted_code = extracted_code,
        content_hash_code = content_hash_code,
    );

    Ok(rust_code)
}

fn option_string_literal(value: Option<&str>) -> String {
    match value {
        Some(value) => format!("Some({value:?})"),
        None => "None".to_owned(),
    }
}

/// Compute a deterministic hash of the fingerprint definition.
fn compute_definition_hash(def: &FingerprintDefinition) -> Result<String, String> {
    // Serialize to a canonical form (sorted keys) for consistent hashing
    let yaml_bytes = serde_yaml::to_string(def)
        .map_err(|e| format!("Failed to serialize definition for hashing: {}", e))?;

    let mut hasher = Hasher::new();
    hasher.update(yaml_bytes.as_bytes());
    let hash = hasher.finalize();

    Ok(format!("blake3:{}", hash.to_hex()))
}

/// Generate code for evaluating all assertions.
fn generate_assertions_code(assertions: &[NamedAssertion]) -> Result<String, String> {
    let mut code_lines = Vec::new();
    code_lines.push("        let generated_assertions: Vec<NamedAssertion> = vec![".to_owned());
    for assertion in assertions {
        code_lines.push(format!("            {assertion:?},"));
    }
    code_lines.push("        ];".to_owned());
    code_lines.push(
        "        let passed_assertions = evaluate_named_assertions_with_diagnose(&generated_assertions, doc, diagnose);".to_owned(),
    );
    code_lines.push(
        "        let all_passed = passed_assertions.iter().all(|result| result.passed);".to_owned(),
    );
    code_lines.push("        let first_failure_reason = passed_assertions".to_owned());
    code_lines.push("            .iter()".to_owned());
    code_lines.push("            .find(|result| !result.passed)".to_owned());
    code_lines.push("            .and_then(|result| result.detail.clone());".to_owned());
    Ok(code_lines.join("\n"))
}

/// Generate code for content extraction.
fn generate_extracted_code(extract: &[ExtractSection]) -> String {
    if extract.is_empty() {
        return "            None".to_string();
    }

    let mut section_inits = Vec::new();
    for section in extract {
        section_inits.push(format!(
            r#"                fingerprint::dsl::parser::ExtractSection {{
                    name: {name}.to_owned(),
                    r#type: {typ}.to_owned(),
                    sheet: {sheet},
                    range: {range},
                    anchor_heading: {anchor_heading},
                    index: {index},
                    anchor: {anchor},
                    pattern: {pattern},
                    within_chars: {within_chars},
                }}"#,
            name = format_args!("{:?}", section.name),
            typ = format_args!("{:?}", section.r#type),
            sheet = codegen_option_string(section.sheet.as_deref()),
            range = codegen_option_string(section.range.as_deref()),
            anchor_heading = codegen_option_string(section.anchor_heading.as_deref()),
            index = codegen_option_display(section.index),
            anchor = codegen_option_string(section.anchor.as_deref()),
            pattern = codegen_option_string(section.pattern.as_deref()),
            within_chars = codegen_option_display(section.within_chars),
        ));
    }

    format!(
        r#"            let sections = vec![
{sections}
            ];
            match fingerprint::dsl::extract::extract(doc, &sections) {{
                Ok(map) => Some(map),
                Err(_) => None,
            }}"#,
        sections = section_inits.join(",\n"),
    )
}

/// Generate code for content hash computation.
fn generate_content_hash_code(content_hash: &Option<ContentHashConfig>) -> String {
    match content_hash {
        Some(config) => {
            let over_entries: Vec<String> = config
                .over
                .iter()
                .map(|name| format!("{:?}.to_owned()", name))
                .collect();
            format!(
                r#"            let over = vec![{over}];
            extracted.as_ref().map(|ext| fingerprint::dsl::content_hash::content_hash(ext, &over))"#,
                over = over_entries.join(", "),
            )
        }
        None => "            None".to_string(),
    }
}

/// Generate Rust source for `Option<String>` — `Some("value".to_owned())` or `None`.
fn codegen_option_string(value: Option<&str>) -> String {
    match value {
        Some(s) => format!("Some({:?}.to_owned())", s),
        None => "None".to_owned(),
    }
}

/// Generate Rust source for `Option<T: Display>` — `Some(42)` or `None`.
fn codegen_option_display<T: std::fmt::Display>(value: Option<T>) -> String {
    match value {
        Some(v) => format!("Some({})", v),
        None => "None".to_owned(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dsl::assertions::{Assertion, NamedAssertion};

    fn base_definition() -> FingerprintDefinition {
        FingerprintDefinition {
            fingerprint_id: "test-model.v1".to_owned(),
            format: "pdf".to_owned(),
            valid_from: None,
            valid_until: None,
            parent: None,
            assertions: vec![NamedAssertion {
                name: Some("has_cover".to_owned()),
                assertion: Assertion::HeadingRegex {
                    pattern: "(?i)cover".to_owned(),
                },
            }],
            extract: vec![],
            content_hash: None,
        }
    }

    #[test]
    fn generate_rust_emits_temporal_metadata_when_present() {
        let mut definition = base_definition();
        definition.valid_from = Some("2021-01-01".to_owned());
        definition.valid_until = Some("2025-12-31".to_owned());

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains(r#"valid_from: Some("2021-01-01"),"#));
        assert!(generated.contains(r#"valid_until: Some("2025-12-31"),"#));
    }

    #[test]
    fn generate_rust_emits_none_temporal_metadata_when_absent() {
        let definition = base_definition();

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains("valid_from: None,"));
        assert!(generated.contains("valid_until: None,"));
    }

    #[test]
    fn generate_rust_emits_parent_when_present() {
        let mut definition = base_definition();
        definition.parent = Some("cbre-appraisal.v1".to_owned());

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains(r#"fn parent(&self) -> Option<&str> {"#));
        assert!(generated.contains(r#"Some("cbre-appraisal.v1")"#));
        assert!(generated.contains(r#"parent: Some("cbre-appraisal.v1"),"#));
    }
}
