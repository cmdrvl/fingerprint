use crate::dsl::assertions::NamedAssertion;
use crate::dsl::parser::{ContentHashConfig, ExtractSection, FingerprintDefinition};
use blake3::Hasher;
use serde_yaml;

/// Generate Rust source implementing the Fingerprint trait from a parsed DSL definition.
pub fn generate_rust(def: &FingerprintDefinition) -> Result<String, String> {
    let source_hash = compute_definition_hash(def)?;
    let compiler_version = env!("CARGO_PKG_VERSION");
    let valid_from = option_string_literal(def.valid_from.as_deref());
    let valid_until = option_string_literal(def.valid_until.as_deref());
    let parent = option_string_literal(def.parent.as_deref());

    let assertions_code = generate_assertions_code(&def.assertions)?;
    let extracted_code = generate_extracted_code(&def.extract);
    let content_hash_code = generate_content_hash_code(&def.content_hash);

    let rust_code = format!(
        r#"//! Generated fingerprint implementation from DSL definition.
//!
//! This file was auto-generated by fingerprint v{compiler_version}.
//! DO NOT EDIT MANUALLY.

use fingerprint::{{Document, Fingerprint, FingerprintResult, AssertionResult}};
use fingerprint::dsl::assertions::{{diagnose_mode, evaluate_assertion}};
use std::collections::HashMap;
use serde_json::{{Value, json}};

pub struct GeneratedFingerprint {{}}

impl Fingerprint for GeneratedFingerprint {{
    fn id(&self) -> &str {{
        "{fingerprint_id}"
    }}

    fn format(&self) -> &str {{
        "{format}"
    }}

    fn parent(&self) -> Option<&str> {{
        {parent}
    }}

    fn fingerprint(&self, doc: &Document) -> FingerprintResult {{
        let mut passed_assertions = Vec::new();
        let mut all_passed = true;
        let mut first_failure_reason: Option<String> = None;
        let diagnose = diagnose_mode();

{assertions_code}

        // Extract content if all assertions passed
        let extracted = if all_passed {{
{extracted_code}
        }} else {{
            None
        }};

        // Compute content hash if enabled and assertions passed
        let content_hash = if all_passed {{
{content_hash_code}
        }} else {{
            None
        }};

        FingerprintResult {{
            matched: all_passed,
            reason: first_failure_reason,
            assertions: passed_assertions,
            extracted,
            content_hash,
        }}
    }}
}}

/// Metadata about the generated fingerprint.
pub const FINGERPRINT_METADATA: FingerprintMetadata = FingerprintMetadata {{
    fingerprint_id: "{fingerprint_id}",
    format: "{format}",
    parent: {parent},
    valid_from: {valid_from},
    valid_until: {valid_until},
    compiler_version: "{compiler_version}",
    source_hash: "{source_hash}",
    source: "dsl",
}};

#[derive(Debug, Clone)]
pub struct FingerprintMetadata {{
    pub fingerprint_id: &'static str,
    pub format: &'static str,
    pub parent: Option<&'static str>,
    pub valid_from: Option<&'static str>,
    pub valid_until: Option<&'static str>,
    pub compiler_version: &'static str,
    pub source_hash: &'static str,
    pub source: &'static str,
}}
"#,
        compiler_version = compiler_version,
        fingerprint_id = def.fingerprint_id,
        format = def.format,
        parent = parent,
        valid_from = valid_from,
        valid_until = valid_until,
        source_hash = source_hash,
        assertions_code = assertions_code,
        extracted_code = extracted_code,
        content_hash_code = content_hash_code,
    );

    Ok(rust_code)
}

fn option_string_literal(value: Option<&str>) -> String {
    match value {
        Some(value) => format!("Some({value:?})"),
        None => "None".to_owned(),
    }
}

/// Compute a deterministic hash of the fingerprint definition.
fn compute_definition_hash(def: &FingerprintDefinition) -> Result<String, String> {
    // Serialize to a canonical form (sorted keys) for consistent hashing
    let yaml_bytes = serde_yaml::to_string(def)
        .map_err(|e| format!("Failed to serialize definition for hashing: {}", e))?;

    let mut hasher = Hasher::new();
    hasher.update(yaml_bytes.as_bytes());
    let hash = hasher.finalize();

    Ok(format!("blake3:{}", hash.to_hex()))
}

/// Generate code for evaluating all assertions.
fn generate_assertions_code(assertions: &[NamedAssertion]) -> Result<String, String> {
    let mut code_lines = Vec::new();

    for (i, assertion) in assertions.iter().enumerate() {
        let generated_name;
        let assertion_name = if let Some(name) = assertion.name.as_deref() {
            name
        } else {
            generated_name = format!("assertion_{}", i);
            &generated_name
        };

        code_lines.push(format!(
            r#"        // Assertion {}: {}
        if !diagnose && !all_passed {{
            passed_assertions.push(AssertionResult {{
                name: "{assertion_name}".to_owned(),
                passed: false,
                detail: Some("Skipped due to earlier assertion failure".to_owned()),
                context: None,
            }});
        }} else {{
            match evaluate_assertion(doc, &{assertion_data:?}) {{
                Ok(result) => {{
                    let passed = result.passed;
                    let detail = result.detail;
                    let context = result.context;
                    passed_assertions.push(AssertionResult {{
                        name: "{assertion_name}".to_owned(),
                        passed,
                        detail: detail.clone(),
                        context: if diagnose && !passed {{ context }} else {{ None }},
                    }});
                    if !passed && first_failure_reason.is_none() {{
                        first_failure_reason = Some(
                            detail.unwrap_or_else(|| "assertion failed".to_owned())
                        );
                        all_passed = false;
                    }}
                }},
                Err(error) => {{
                    passed_assertions.push(AssertionResult {{
                        name: "{assertion_name}".to_owned(),
                        passed: false,
                        detail: Some(error.clone()),
                        context: None,
                    }});
                    if first_failure_reason.is_none() {{
                        first_failure_reason = Some(error);
                        all_passed = false;
                    }}
                }}
            }}
        }}"#,
            i + 1,
            assertion_name,
            assertion_name = assertion_name,
            assertion_data = assertion.assertion,
        ));
    }

    Ok(code_lines.join("\n\n"))
}

/// Generate code for content extraction.
fn generate_extracted_code(extract: &[ExtractSection]) -> String {
    if extract.is_empty() {
        return "            None".to_string();
    }

    let mut code_lines = vec!["            let mut extracted = HashMap::new();".to_string()];

    for section in extract {
        code_lines.push(format!(
            r#"            // Extract section: {}
            // TODO: Implement extraction for type: {}
            extracted.insert("{}.to_owned(), json!("extracted_placeholder"));"#,
            section.name, section.r#type, section.name
        ));
    }

    code_lines.push("            Some(extracted)".to_string());
    code_lines.join("\n")
}

/// Generate code for content hash computation.
fn generate_content_hash_code(content_hash: &Option<ContentHashConfig>) -> String {
    match content_hash {
        Some(config) => {
            format!(
                r#"            // Content hash over fields: {:?}
            // TODO: Implement {} content hash computation
            Some("{}:placeholder".to_owned())"#,
                config.over, config.algorithm, config.algorithm
            )
        }
        None => "            None".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dsl::assertions::{Assertion, NamedAssertion};

    fn base_definition() -> FingerprintDefinition {
        FingerprintDefinition {
            fingerprint_id: "test-model.v1".to_owned(),
            format: "pdf".to_owned(),
            valid_from: None,
            valid_until: None,
            parent: None,
            assertions: vec![NamedAssertion {
                name: Some("has_cover".to_owned()),
                assertion: Assertion::HeadingRegex {
                    pattern: "(?i)cover".to_owned(),
                },
            }],
            extract: vec![],
            content_hash: None,
        }
    }

    #[test]
    fn generate_rust_emits_temporal_metadata_when_present() {
        let mut definition = base_definition();
        definition.valid_from = Some("2021-01-01".to_owned());
        definition.valid_until = Some("2025-12-31".to_owned());

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains(r#"valid_from: Some("2021-01-01"),"#));
        assert!(generated.contains(r#"valid_until: Some("2025-12-31"),"#));
    }

    #[test]
    fn generate_rust_emits_none_temporal_metadata_when_absent() {
        let definition = base_definition();

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains("valid_from: None,"));
        assert!(generated.contains("valid_until: None,"));
    }

    #[test]
    fn generate_rust_emits_parent_when_present() {
        let mut definition = base_definition();
        definition.parent = Some("cbre-appraisal.v1".to_owned());

        let generated = generate_rust(&definition).expect("generated rust source");

        assert!(generated.contains(r#"fn parent(&self) -> Option<&str> {"#));
        assert!(generated.contains(r#"Some("cbre-appraisal.v1")"#));
        assert!(generated.contains(r#"parent: Some("cbre-appraisal.v1"),"#));
    }
}
